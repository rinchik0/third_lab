## Описание
Это учебный проект, лабораторное задание по дисциплине Программирование на Java.

## Задание
Сравнить производительность ArrayList и LinkedList.
Необходимо написать код, который бы вызывал основные методы коллекций определенное (1000 или 2000, или любое другое) количество раз. При этом должно засекаться время.
Минимально необходимо протестировать методы: add, delete, get.
После этого вывести таблицу с результатами (метод, сколько раз выполнялся, время выполнения).

## Требования
- Качество кода
- Unit tests
- JavaDocs
- Maven project
- Работа с git (история коммитов + настройка gitignore)

## Выводы о тестировании производительности
### Вывод Main'а
-----------------------------------------------------------------------------
| Метод                | Кол-во операций | ArrayList (мс) | LinkedList (мс) |
|----------------------|-----------------|----------------|-----------------|
|--------------------------------| Integer |--------------------------------|
| add (to head)        | 1000            | 0,20           | 0,00            |
| add (to middle)      | 1000            | 0,10           | 3,49            |
| add (to back)        | 1000            | 0,11           | 0,20            |
| remove (from head)   | 1000            | 0,20           | 0,20            |
| remove (from middle) | 1000            | 0,20           | 2,79            |
| remove (from back)   | 1000            | 0,19           | 0,00            |
| get                  | 1000            | 0,00           | 0,90            |
|----------------------|-----------------|----------------|-----------------|
| add (to head)        | 10000           | 29,00          | 1,20            |
| add (to middle)      | 10000           | 14,05          | 327,14          |
| add (to back)        | 10000           | 0,10           | 0,10            |
| remove (from head)   | 10000           | 22,03          | 0,10            |
| remove (from middle) | 10000           | 11,56          | 271,59          |
| remove (from back)   | 10000           | 0,40           | 0,10            |
| get                  | 10000           | 0,00           | 58,40           |
|-------------------------------| Character |-------------------------------|
| add (to head)        | 1000            | 0,00           | 0,00            |
| add (to middle)      | 1000            | 0,10           | 3,19            |
| add (to back)        | 1000            | 0,20           | 0,10            |
| remove (from head)   | 1000            | 0,10           | 0,00            |
| remove (from middle) | 1000            | 0,00           | 2,69            |
| remove (from back)   | 1000            | 0,00           | 0,00            |
| get                  | 1000            | 0,00           | 0,60            |
|----------------------|-----------------|----------------|-----------------|
| add (to head)        | 10000           | 27,31          | 0,20            |
| add (to middle)      | 10000           | 14,25          | 325,11          |
| add (to back)        | 10000           | 0,20           | 0,00            |
| remove (from head)   | 10000           | 22,53          | 0,10            |
| remove (from middle) | 10000           | 11,46          | 267,40          |
| remove (from back)   | 10000           | 0,00           | 0,00            |
| get                  | 10000           | 0,00           | 60,10           |
-----------------------------------------------------------------------------

Я протестировала программу на Integer и Character данных. Результат на них практически идентичен, из чего я могу сделать вывод, что от типа данных будет зависеть не многое. Для анализа мне хватит только статистики от Integer.

### Детальный анализ по операциям

1. Операции добавления.
- add (to head): LinkedList очень быстр (O(1)), в то время как ArrayList должен сдвигать все существующие элементы (O(n)), поэтому он медленнее, особенно при большом количестве операций.
- add (to middle): LinkedList работает значительно медлененно (O(n)), так как требует навигации до середины списка. ArrayList также медленный (O(n)) из-за необходимости сдвигать элементы. Но тут ему надо сдвигать не все элементы, а половину. Однако передвижение по ссылкам осуществляется медленнее, чем по поиндексам.
- add (to back): и ArrayList, и LinkedList достаточно быстры (O(1)).
2. Операции удаления.
- remove (from head): LinkedList очень быстр (O(1)), а ArrayList требует сдвига элементов (O(n)).
- remove (from middle): и LinkedList, и ArrayList медленнее (O(n)) из-за необходимости поиска элемента и сдвига.
- remove (from back): и ArrayList, и LinkedList очень быстры (O(1)).
3. Операция поиска.
- get: ArrayList очень быстр (O(1)), тогда как LinkedList медленнее (O(n)), так как требует итерации по списку.

### Общий вывод

Выбор между ArrayList и LinkedList зависит от предполагаемого использования.

ArrayList обычно быстрее для операций доступа по индексу (get), добавления в конец (add (to back)), и удаления из конца (remove (from back)) (O(1) время). LinkedList более эффективен для добавления и удаления в начале (add (to head), remove (from head)) (O(1) время), но медленнее для операций, требующих поиска элемента (добавление и удаление в середине, get) (O(n) время).

Влияние размера данных: С увеличением количества операций (с 1000 до 10000), разница в производительности становится более заметной, особенно для операций, требующих перебора элементов (add (to middle), remove (from middle), и get для LinkedList). Время выполнения этих операций значительно увеличивается для LinkedList, в то время как для ArrayList увеличение, как правило, менее значительно.

### Когда что использовать?

Когда...

1) важен быстрый доступ по индексу (get).
2) добавление и удаление происходит в основном в конце списка.
3) относительно редко выполняются операции добавления и удаления в середине или в начале.

... выгоднее использовать ArrayList.

А когда...

1) часто выполняются операции добавления и удаления в начале списка (очереди/стеки).
2) производительность удаления и добавления в середине не критична, а в начале важна.

... выгоднее использовать LinkedList.

## Условия тестов
- JVM: OpenJDK 20.0.2
- Прогрев: 10 итераций
- Усреднение: 10 замеров
